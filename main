from scipy import linalg
from matplotlib import pyplot as plt

import eig_stub as es
import rx_data
import rx_data as rx
from scipy.integrate import quad
import numpy as np

''' Define the geometry. Set up the width and step-size of your geometry.'''
system_size = 1  # m
delta_x = .1  # m
geo = [system_size, delta_x]

def main():
    # read in information
    microxs, fiss_yield = es.read_xs()
    # calculate the const]ants
    consts = es.calculate_constants()
    # calculate the flux (the eigen vector from the correct eigen value)
    eigen_values, eigen_vectors = es.solve_flux(geo, microxs, fiss_yield, consts)
    # plot the correct eigen vector using plt.plot()

    flux = np.sum((es.calculate_constants()['sigf']*10**2) * eigen_vectors * (202.5) * geo[1])

    reactor_power = 1  # 1MW = MJ/s
    reactor_power_1 = reactor_power * 6.2415064799632 * 10**18  # MJ/s to MeV

    scale = reactor_power_1 / flux
    print(flux)
    print(scale)

    plt.plot(scale * abs(eigen_vectors))
    plt.title("Flux Profile Scaled According to Power")
    plt.xlabel("Distance")
    plt.ylabel("Flux")
    plt.show()

    '''
    This time loop will be used later on to facilitate the burn-up section of the code. The homework that will
    put this together will have more instruction for doing this. 
    delta_t = None
    simulation_time = None
    time_steps = [0]
    evolution_flux = []
    evolution_comp = []
    for t in time_steps:
        # initial values
        ### solve_flux() this is the eigen value code
        ### burn_up() this is your burnup code (when it's done)
        ### update number density
    '''

if __name__ == "__main__":
    main()
